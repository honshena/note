# Git版本控制管理

## 初始化项目

`git init`

## 配置

### 查看配置

`git config -l`

### 移除设置

`git config --unset [--global] 设置项`

### 配置用户信息

`git [--global] config user.name '用户名'`

`git [--global] config user.email '邮箱地址'`  *--global全局配置*

### 配置文件

git配置文件

`项目/.git/config`

项目git配置文件

`项目/.gitconfig` *该设置拥有最高优先级*

linux下配置文件

`/etc/gitconfig`

### 配置别名

`git config --global 别名 '命令1 参数'`

## 创建版本库副本

`git clone 仓库名` `git clone ssh链接|https链接`

##  添加文件到版本库

### 添加文件夹

`git add 文件夹`

### 添加文件

`git add 文件名.文件后缀`

*tips: 不要将有冲突的文件执行git add,虽然这会清除索引中的冲突但是这是错误的,另外可以将误添加进版本库的文件使用`git reset HEAD 文件名.文件后缀`的方式从索引中删除*

### 添加所有

`git add *`	*暂存一个文件文件的状态从未追踪变为已追踪*

*tips: git是基于SHA散列计i算对象内容,git追踪的是内容而不是文件如果两个文件内容完全一样,git在对象库只保存一份blob'如果文件发生了变化git会重新计算一个新的SHA1值然后替换原来的blob对象git存储的是文件的每个版本而不是差异git以一个文件的内容的散列值作为文件名*

## 版本库文件修改

## 文件删除

`git rm [--cached] 文件名`	*--catched会删除索引的文件并将其保留在工作目录中,git rm会将其文件从索引和工作目录中都删除*

*tips:文件更改后需要重新提交*

### 文件重命名

`git mv 文件1 文件2`

*tips:文件更改后需要重新提交*

### 文件内容读取

`git cat-file -p 散列值`

**使用`git rev-parse 散列值开始部分`获取到完整的40长度散列值**

## 状态管理

`git staus`

## 分支

### 查看分支

`git branch`

`git show-branch [分支名]` *显示的结果中以破折号`--`分割上方是分支名每行一个感叹号`!`或星号`*`表示当前分支后跟方括号如`![分支名]提交信息`,分割下方表示每一个分支的中的提交矩阵`+`表示提交`-`表示合并`*`表示存在于活动分支的提交*

*tips: `git show-branch bug/*`允许通配符匹配一个组下的分支*

### 创建分支

`git branch 分支名 [提交名或散列值]` *从分支作为开始提交*

### 切换(检出)分支

`git checkout 分支名 [-f]` *-f表示强制检出丢失对工作目录的修改* 

*tips: 如果有未提交的更改时进行检出,如果不明确要求,Git会排除本地工作树中的数据的删除和修改,工作目录中未被追踪的文件和目录Git始终置之不管但是如果一个文件的本地修改不同于新分支上的变更,Git会发出错误信息并拒绝检出分支,当因为文件差异导致时可以使用`git diff 文件`查看差异*

`git checkout 分支名 -m` *工作目录改变和被检出的分支合并*

*tips: Git合并分支后留下了合并冲突的指示需要解决*

`git checkout -b 分支名` *创建一个分支并检出到该分支*

*参数`--ours`和`--theirs`作为从冲突合并的一边检出的的简写,这两个参数只能在冲突解决期间使用*

### 删除分支

`git branch -d 分支名` *必需始终选择一个非当前活动分支,Git不会允许你删除一个包含不存在于当前分支中的提交的分支如果要强制删除使用参数`-D`*

### 合并分支

`git merge 分支名`

*tips: 当出现合并冲突使用`git diff`查看冲突的程度或`git log --merge --left-right -p`*

### 终止合并

`git reset --hard HEAD` *将工作目录和索引还原到git merge之前*

`git reset --hard ORIG_HEAD` *将原始分支HEAD保存在ORIG_HEAD*

#### 参数

`--soft`  将HEAD引用指向给定提交,索引和工作目录的内容保持不变

`--mixed`  将HEAD指向给定提交,索引内容改变以符合给定提交的树结构但是工作目录内容不变

`--hard` 将HEAD指向给定提交,索引内容和工作目录内容改变以符合给定的树结构

### 恢复分支

`git reflog`

## 提交

### 提交单个文件

`git commit 文件名.文件后缀`

### 提交所有

`git commit -m '提交说明' `	*--message*

`git commit -a` *--all选项会自动提交所有未暂存的和未追踪的文件*

*tips: git不会处理空文本提交*

## 查看提交

### 查看历史提交

#### 历史记录

`git log [-l|-p|--graph][提交名] `  *不加提交名等于`git log HEAD,-l以列表的形式,-p使用散列值--graph使用图`*

`git show-branch [--more=查看提交次数]`

> commit a15c88e2cb0c5fca3b322257

*tips:a15c88e2cb0c5fca3b322257为提交码*

#### 查看在分支1但不在其他分支的所有提交

`git log [^分支1 ^分支2...] 分支N` *选择在分支N但不在分支1,2,3...的所有提交*

### 查看单次提交

`git show 提交码`

`git show --pretty=fulller` *查看提交的其它细节*

### 查看提交差异 

`git diff 提交码1 提交码2`

### 查看提交图

`gitk`

### 查看对称差中的修订集合

`git rev-list 提交A 提交B` 或 `git merge-base --all 提交A 提交B`

### 查找提交

#### 查找错误提交

`git bisect [help|start|bad|good|new|old|terms|skip|next|reset|visualize|view|replay|log|run]` *首先确定坏提交(往往是当前的HEAD,好提交通常在历史记录的某个地方,你可以猜测从某一个好提交作为开始,这可以是tag这样的标签或是修订前的某个提交)*

```bash
# 示列
git bisect start
git bisect bad # HEAD为bad
git bisect good v2.1.0 # v2.1.0是good
# 执行上述命令后git会列出这其中的所有修订版本,你只需要不断回答git这个修订版本是好是坏,git会利用二分查找查找出坏提交
# ...重复回答git某个修订版本提交是好是坏
git bisect good | git bisect bad
# 完成二分查找后 git branch不在master分支上需要使用git bisect reset回到master因为二分的过程是在分离的HEAD上执行
git bisect reset
```

*tips: 通过log<sub>2</sub>X(X为原始修订版本次数)步来确定出错的那个提交在二分搜索过程中Git维护一个日志来记录你的回答和提交ID通过`git  bisect log`查看如果在查找过程中迷失或你想重新开始可以通过`git bisect replay`命令使用日志文件作为输入,这是一种很好的机制在此过程中回退一步并选用其他的路径*

`git bisect visualize --pretty=oneline` *可视化检查提交范围的内容,如果设置环境变量DISPLAY则Git会使用图形工具gitk如果没有Git会使用`git log`这种情况下`--pretty=online`会很有用*

#### 查看文件的提交变更信息

`git blame [-L] -- 文件` *-L  process only line range `<start>`,`<end>` or function :`<funcname>`*

*tips: 查看某个文件中的每一行是谁最后修改和哪次提交做出了变更 `--`用于分隔文件和参数*

#### 查找文件变更的提交

`git log -Sinclude --pretty=oneline --abbrev-commit -- 文件夹或文件`

## 差异

### 工作目录和索引的差异

`git diff`

### 工作目录和给定提交

`git diff 提交码`

### 索引和给定提交

`git diff --cached 提交码`

### 两个提交

`git diff 提交1 提交2`

### 参数

`--M` 查找重命名并且生成一个简化的输出

`-w|--ignore-all-space` 比较文件忽略空白字符

`--stat` 显示针对两个树状态之间差异的统计数据

`--color` 输出结果使用多种颜色显示

`--ours`  同`git diff HEAD`

## Git原理

### Git追踪内容

​	Git的内容追踪主要表现为两种关键的方式,git的对象库基于对象内容的散列计算值,而不是基于用户原始文件布局的文件名或者目录名设置,因此当git放置一个文件到对象库中的时候,它基于数据的散列值而不是文件名.

​	如果两个文件内容完全一样,无论是否在相同目录,Git在对象库里只保存一份blob形式的内容副本*Git是基于文件内容计算每一个文件的SHA1值然后将blob对象放到对象库里并以SHA1值作为索引*

​	如果这些文件发生了一些变化,Git会为它计算一个新的SHA1值然后识别出它现在是一个新的blob对象,并将它加入到Git对象库中,原来的blob在对象库中保持不变

​	其次文件从一个版本变化到另一个版本,Git内部的数据库有效地存储每一个文件的每一个版本而不是差异因为Git使用一个文件的全部内容的散列值作为文件名,所以Git必须对每一个文件的完整副本进行操作.Git不能将工作或者对象库条目建立在文件内容的一部分或者文件的两个版本的差异之上.

**Git索引机制: .git/objects/hash/树对象内容 Git数据存储: blob对象/树对象**

Git的物理数据布局并不模仿用户的文件目录结构相反Git有一个完全不同的结构却可以重建用户的原始布局,Git内部

### Git打包文件

​	Git使用了一种叫做打包文件(package)的更有效的存储机制,要创建一个打包文件Git首先定位内容非常相似的全部文件,然后为它们之一存储整个内容,之后计算相似文件之间的差异并且只存储差异

​	Git维护打包文件表示中每个完整文件(包括完整的内容的文件和通过差异重建出来的文件)的原始blob的SHA1值,这给定位包内的对象索引机制提供了基础

### Git对象库图示

​	blob对象是数据库结构的底端,它什么也不引用而且只被树对象引用

​	树对象指向对个blob对象,也可以指向其它树对象

​	每个提交对象指回它的一个或多个父提交: 数据流从父提交流向子提交

![对象库](https://images-1300732204.cos.ap-chengdu.myqcloud.com/14310957-3fdce556428c8596.png)

![提交后的](https://images-1300732204.cos.ap-chengdu.myqcloud.com/14310957-9539ae06bcc80e07.png)

![](https://images-1300732204.cos.ap-chengdu.myqcloud.com/14310957-6a1e362e5d7cf1e5.png)

![](https://images-1300732204.cos.ap-chengdu.myqcloud.com/14310957-a8e69d240b7b1a50.png)

### Git文件管理和索引

#### Git文件

​	Git通过目录树的对象来追踪文件的路径名,当使用`git add`命令时Git会给添加的每一个文件的内容创建一个对象,但它并不会马上成为树创建一个对象,相反索引更新了,索引位于`.git/index`中,它跟踪文件的路径名和相应的blob每次执行命令(如:git add|rm|mv)时Git会用新的路径名和blob'信息来更新索引

#### 查看文件关联索引

`git ls-files -s`

#### 查看树

`git write-tree`

`git cat-fille -p 散列值4位以上`

#### 提交树对象

`git commit-tree 散列值`

#### 创建标签

`git tag -m '提交信息' 标签 散列值`

`git rev-parse 标签` *查看标签对象*

​	标签指向提交对象,通常情况下git通过某些分支来给特定的提交命名标签Git通常给指向树对象的提交对象打标签,这个树对象包含版本库中文件和目录的整个层次结构的总状态

#### Git文件分类

​	已追踪的(Tracked): 在版本库中或已暂存到索引中的文件

​	被忽略的(Ignored): 必须在版本库中被明确声明为不可见或被忽略

​	未追踪的(Untracked): Git将工作目录下的所有文件作为一个集合减去已追踪的和被忽略的,剩下的就是为追踪的文件

*tips: `.gitignore`文件可以忽略文件和文件夹,Git按照下列优先级对忽略文件列表的增编(高->低)*

- 在命令行指定模式
- 从相同目录下的`.gitignore`文件读取的模式
- 上层目录的模式,向上进行,因此当前目录的模式可以推翻上层目录的模式,而最接近当前目录的上层目录的模式优先于更上层的目录模式
- 来自`.git/info/exclude`文件的模式
- 来自配置变量core.excludedfile指定的文件中的模式                                                                                        

### Git提交

#### 原子变更集

​	每一个Git提交都代表一个相对于之前的状态的单个原子变更集,对于一个提交中所有做过的改动,无论多少目录,文件,行,字节的改变要么全部应用要么全部拒绝

#### 识别提交

​	Git通过显示或隐式引用来指代每一个提交,唯一的SHA1提交ID的显示引用,始终指向最新的提交的HEAD是隐式引用,Git提供不同的机制为提交命名

##### 绝对提交名

​	散列ID是绝对名,只能表示唯一确定的一个提交,无论处于版本库历史中的任何位置,哈希ID都对应相同的提交,每一个提交的散列id都是全局唯一的,不仅仅是对某个版本库而是对任意和索引的版本库都是唯一的

##### 引用和符号引用

​	引用(ref)是一个散列值,指向Git对象库中的对象,虽然一个引用可以指向任意的Git对象但是它通常指向提交对象

​	符号引用(symref)间接指向Git对象

​	本地特性分支名称,远程跟踪分支名称和标签名都是引用

​	每一个符号引用都以ref/开始明确全称并且都分层存储在版本库的`.git/refs/`目录中,`refs/heads/ref`代表本地分支,`ref/remotes/ref`代表远程跟踪分支,`ref/tags/ref`代表标签

##### 相对提交名

​	比如`master`和`master^`,其中`master^`始终指向的是`master`分支中倒数第二个提交,给定一个提交`C`,`C^1`是其第一个父提交,`C^2`是其第二个父提交`C^3`是其第三个父提交

​	波浪线`~`用于返回父提交之前并选择上一个提交,同样,给定一个提交`C`,`C~1`是其第一个父提交,`C~2`是其第一个祖父提交`C~3`是其第一个曾祖父提交 

##### Git历史提交

​	显示历史提交的命令是`git log`比起ls还有更多的选项,参数,着色器,选择器,格式化器,铃铛口哨和其他小玩意er等

​	`git log`和`git log HEAD`是一样的从HEAD找到历史记录的提交日志信息,变更从HEAD提交开始显示,并从图中回溯,按照时间逆序显示,`git log 提交名`日志将从该提交开始回溯输出

##### 提交范围

​	Git命令允许指定提交的范围,双句点`..`形式表示一个范围,如"开始..结束"(`git log X..Y`显示X提交到Y提交的历史记录)

##### 查找提交

​	`git bisect`: 找出哪次提交使代码运行时异常崩溃

​	`git blame`: 指明文件的哪一行是谁修改和哪次提交做出变更

​	`pickaxe`: 带有`-S`选项的`git log`命令 

### 分支

​	一个分支通常代表一个单独的客户发布版,如果你想开始项目的1.1版本,但你知道一些客户想要保持1.0版,那就把旧版留作一个单独的分支

​	一个分支可以封装一个开发阶段,如原型,测试,稳定或邻近发布

​	一个分支可以隔离一个特性的开发或研究特别复杂的bug

​	每一个分支可以代表单个贡献者的工作

​	Git把列出的这些分支视为特性分支或开发分支,"特性"仅指每个分支在版本库中有特定的目的

**Git基本哲学: 所有的分支生而平等,所有的版本库生而平等**

#### 分支还是标签

​	标签和分支是出于不同的目的.标签是一个静态的名字,它不随着时间的推移而改变,一旦应用你不应该对他做任何的改动,它相当于地上支柱的一个参考点,另一方面,分支是动态的,随着你每一次的提交而移动,分支名用来跟随你的开发

​	命名分支和标签: 这个名字是静态且不变的,还是随开发动态变化的,前者是标签后者是分支,除非你有一个令人信服的理由否则避免使用相同的名称命名分支和标签

#### 分支命名

	1. 使用`/`创建一个分层命名方案如bug/pr-1,但是该分支名不能以斜杠结尾
	2. 分支名不能以-开头
	3. 斜杠分割的组件不能以.开头如:像feature/.new是无效的
	4. 分支名任何的地方不应该有两个连续的`..`
	5. 分支名不能有空格或空白字符以及`~ ^ : ? * [`也不能有ASCLL码小于`\040`的字符或DEL字符`\177`

#### 分离HEAD分支

​	Git会创建一个分离的HEAD

	1. 检出的提交不是分支的头部
	2. 检出一个追踪分支
	3. 检出标签引用的提交
	4. 启动`git bisect`操作
	5. 使用`git submodule update`

#### Git追踪冲突

	1. `.git/MERGE_HEAD`包含合并进来的提交SHA1值,不必自己使用SHA1,提及MERGE_HEAD,Git都会去查看那个文件
 	2. `.git/MERGE_MSG`包含当解决冲突后执行git commit命令时用到的默认合并消息
 	3. Git的索引包含每个冲突文件的3个副本: 合并基础,我们的版本和他们的版本分别编号为 1 2 3
 	4. 冲突的版本不存储在索引中相反存储在工作目录中

#### Git合并策略

- 退化合并: 有两种导致合并的退化分别是: 已经是最新的(当前来自其他分支的所有提交都存在于目标分支上时及时在它自己的分支上前进了目标分支还是已经更新到最新的)和快进的(当分支HEAD已经在其他分支中完全存在或表示时,就会发生快进合并)

- 常规合并: 有解决,递归和章鱼

  - 解决: 操作两个分支定位共同的祖先作为合并基础然后执行一个第三方的合并通过对当前分支施加从合并基础到其他分支HEAD的变化
  - 递归: 一次处理两个分支,能处理在两个分支之间有多个合并基础的情况,Git会生成一个临时合并来包含所有的合并基础,然后以此为基础通过一个普通的第三方合并算法导出两个给定分支的最终合并
  - 章鱼: 合并两个分支以上,内部多次调用递归合并策略,要合并的每一个分支调一次但是这个策略不能处理需要用户交互解决的冲突,这种情况下需要做常规合并

  *git可以完成压制提交在执行git merge和git pull时给出`--squash`但是压制会扰乱git的历史记录*

### Git更改提交

#### 
